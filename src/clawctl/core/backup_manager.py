"""Git-based backup system for OpenClaw user data."""

from __future__ import annotations

import fnmatch
import logging
import os
import shutil
import signal
import sys
import time
from datetime import datetime, timezone
from pathlib import Path

import git
import schedule

from clawctl.core.paths import Paths
from clawctl.models.config import BackupConfig, Config

logger = logging.getLogger(__name__)


class BackupManager:
    """Manages git-based backups of per-user OpenClaw workspace/memory files.

    For each user, a git repo lives at <data_root>/users/<username>/backup/.
    Periodically, files matching include_patterns are copied from the user's
    openclaw directory into the backup repo and committed.
    """

    def __init__(self, config: Config) -> None:
        self.config = config
        self.paths = Paths(config.clawctl.data_root, config.clawctl.build_root)
        self.backup_config = config.clawctl.backup

    def init_user_backup(self, username: str) -> None:
        """Initialize a git backup repo for a user."""
        backup_dir = self.paths.user_backup_dir(username)
        backup_dir.mkdir(parents=True, exist_ok=True)

        if (backup_dir / ".git").is_dir():
            return  # already initialized

        repo = git.Repo.init(backup_dir)

        # Create .gitignore
        gitignore = backup_dir / ".gitignore"
        gitignore.write_text("# Auto-generated by clawctl\n*.tmp\n*.lock\n")

        repo.index.add([".gitignore"])
        repo.index.commit("Initial backup repository")

    def backup_user(self, username: str) -> bool:
        """Backup a single user's openclaw data.

        Copies matching files from the openclaw dir into the backup repo
        and commits if there are changes.

        Returns True if a new commit was created.
        """
        source_dir = self.paths.user_openclaw_dir(username)
        backup_dir = self.paths.user_backup_dir(username)

        if not source_dir.is_dir():
            logger.warning("Source dir missing for %s, skipping", username)
            return False

        if not (backup_dir / ".git").is_dir():
            self.init_user_backup(username)

        repo = git.Repo(backup_dir)

        # Copy matching files from source to backup
        copied = self._sync_files(source_dir, backup_dir)
        if not copied:
            logger.debug("No matching files found for %s", username)

        # Stage all changes
        repo.git.add("-A")

        # Check for changes
        if not repo.is_dirty() and not repo.untracked_files:
            logger.debug("No changes for %s", username)
            return False

        # Commit
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        repo.index.commit(f"Backup {timestamp}")
        logger.info("Backed up %s at %s", username, timestamp)
        return True

    def backup_all(self) -> dict[str, bool]:
        """Backup all configured users.

        Returns {username: True/False} indicating if a commit was made.
        """
        results = {}
        for user in self.config.users:
            try:
                results[user.name] = self.backup_user(user.name)
            except Exception:
                logger.exception("Backup failed for %s", user.name)
                results[user.name] = False
        return results

    def _sync_files(self, source_dir: Path, backup_dir: Path) -> int:
        """Copy files matching include_patterns from source to backup.

        Returns number of files copied.
        """
        count = 0
        for pattern in self.backup_config.include_patterns:
            for source_file in source_dir.glob(pattern):
                if not source_file.is_file():
                    continue
                rel = source_file.relative_to(source_dir)
                dest = backup_dir / rel
                dest.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(source_file, dest)
                count += 1

        # Clean up files in backup that no longer exist in source
        self._remove_stale_files(source_dir, backup_dir)
        return count

    def _remove_stale_files(self, source_dir: Path, backup_dir: Path) -> None:
        """Remove files from backup that no longer exist in source."""
        for backup_file in backup_dir.rglob("*"):
            if not backup_file.is_file():
                continue
            if backup_file.name.startswith(".git"):
                continue
            rel = backup_file.relative_to(backup_dir)
            if rel.parts[0] == ".git":
                continue
            source_file = source_dir / rel
            if not source_file.is_file():
                backup_file.unlink()

    # --- Daemon management ---

    def run_periodic(self) -> None:
        """Run periodic backup loop (blocking). Handles SIGTERM for clean shutdown."""
        interval = self.backup_config.interval_minutes
        logger.info("Starting periodic backup every %d minutes", interval)

        running = True

        def handle_signal(signum, frame):
            nonlocal running
            logger.info("Received signal %d, stopping backup daemon", signum)
            running = False

        signal.signal(signal.SIGTERM, handle_signal)
        signal.signal(signal.SIGINT, handle_signal)

        # Run immediately on start
        self.backup_all()

        schedule.every(interval).minutes.do(self.backup_all)

        while running:
            schedule.run_pending()
            time.sleep(1)

        logger.info("Backup daemon stopped")

    def start_daemon(self, config_path: Path) -> int:
        """Start the backup daemon as a background process.

        Args:
            config_path: Absolute path to the clawctl.toml config file.

        Returns the PID of the spawned process.
        """
        import subprocess

        pid_file = self.paths.backup_pid_file

        if self.is_daemon_running():
            msg = "Backup daemon is already running"
            raise RuntimeError(msg)

        # Spawn a detached process running this module with the config path
        proc = subprocess.Popen(
            [
                sys.executable,
                "-m",
                "clawctl.core.backup_manager",
                str(config_path),
            ],
            start_new_session=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

        pid_file.write_text(str(proc.pid))
        return proc.pid

    def stop_daemon(self) -> bool:
        """Stop the backup daemon. Returns True if it was running."""
        pid_file = self.paths.backup_pid_file

        if not pid_file.is_file():
            return False

        pid = int(pid_file.read_text().strip())

        try:
            os.kill(pid, signal.SIGTERM)
        except ProcessLookupError:
            pass  # already dead

        pid_file.unlink(missing_ok=True)
        return True

    def is_daemon_running(self) -> bool:
        """Check if the backup daemon is currently running."""
        pid_file = self.paths.backup_pid_file

        if not pid_file.is_file():
            return False

        pid = int(pid_file.read_text().strip())

        try:
            os.kill(pid, 0)  # signal 0 = check existence
            return True
        except (ProcessLookupError, PermissionError):
            # Stale PID file
            pid_file.unlink(missing_ok=True)
            return False


def _run_daemon_main() -> None:
    """Entry point when this module is run as a script for the daemon process."""
    from clawctl.core.config import load_config

    if len(sys.argv) < 2:
        print("Usage: python -m clawctl.core.backup_manager <config_path>")
        sys.exit(1)

    config_path = Path(sys.argv[1])
    if not config_path.is_file():
        print(f"Config file not found: {config_path}")
        sys.exit(1)

    config = load_config(config_path)

    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        handlers=[
            logging.FileHandler(Paths(config.clawctl.data_root, config.clawctl.build_root).logs_dir / "backup.log"),
            logging.StreamHandler(),
        ],
    )

    manager = BackupManager(config)
    manager.run_periodic()


if __name__ == "__main__":
    _run_daemon_main()
